name: ğŸš€ Deploy to Azure AKS

on:
  workflow_call:
    inputs:
      backend_image:
        required: true
        type: string
        description: 'Backend image to deploy'
      frontend_image:
        required: true
        type: string
        description: 'Frontend image to deploy'
      environment:
        required: true
        type: string
        description: 'Environment to deploy to (development/production)'
  workflow_dispatch:
    inputs:
      backend_image:
        required: true
        type: string
        description: 'Backend image to deploy'
      frontend_image:
        required: true
        type: string
        description: 'Frontend image to deploy'
      environment:
        required: true
        type: choice
        description: 'Environment to deploy to'
        options:
          - development
          - production

env:
  AZURE_RESOURCE_GROUP: 'NetworkWatcherRG'
  AKS_CLUSTER_NAME: 'runstackcluster'

jobs:
  deploy:
    name: ğŸš€ Deploy to Azure AKS
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ğŸ”§ Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: ğŸ”§ Get AKS credentials
        run: |
          az aks get-credentials --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AKS_CLUSTER_NAME }}

      - name: ğŸ” Determine deployment environment and manifest path
        id: deploy_env
        run: |
          if [[ "${{ inputs.environment }}" == "production" ]]; then
            echo "manifest_path=k8s/prod/" >> $GITHUB_OUTPUT
          else
            echo "manifest_path=k8s/dev/" >> $GITHUB_OUTPUT
          fi

      - name: ğŸš€ Deploy to Kubernetes
        run: |
          # Update image tags in k8s manifests
          sed -i "s|runstackregistry.azurecr.io/backend.*:.*|${{ inputs.backend_image }}|g" ${{ steps.deploy_env.outputs.manifest_path }}backend-deployment.yaml
          sed -i "s|runstackregistry.azurecr.io/frontend.*:.*|${{ inputs.frontend_image }}|g" ${{ steps.deploy_env.outputs.manifest_path }}frontend-deployment.yaml
          
          # Apply k8s manifests
          kubectl apply -f ${{ steps.deploy_env.outputs.manifest_path }} --validate=true || {
            echo "âš ï¸ Validation failed, applying without validation..."
            kubectl apply -f ${{ steps.deploy_env.outputs.manifest_path }} --validate=false
          }
          
          # Apply common services if not using environment-specific manifests
          if [[ "${{ steps.deploy_env.outputs.manifest_path }}" == "k8s/dev/" ]] || [[ "${{ steps.deploy_env.outputs.manifest_path }}" == "k8s/prod/" ]]; then
            kubectl apply -f k8s/backend-service.yaml --validate=false
            kubectl apply -f k8s/frontend-service.yaml --validate=false
            kubectl apply -f k8s/ingress.yaml --validate=false
          fi
          
          # Wait for rollout
          kubectl rollout status deployment/backend --timeout=300s
          kubectl rollout status deployment/frontend --timeout=300s

      - name: ğŸ”— Get Service URLs
        run: |
          echo "ğŸ“¡ Getting service information..."
          
          # Get external IPs from Azure Load Balancer
          FRONTEND_IP=$(kubectl get service frontend -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          BACKEND_IP=$(kubectl get service backend -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          echo "Frontend External IP: $FRONTEND_IP"
          echo "Backend External IP: $BACKEND_IP"
          
          # Set environment variables for next step
          echo "FRONTEND_URL=http://$FRONTEND_IP" >> $GITHUB_ENV
          echo "BACKEND_URL=http://$BACKEND_IP" >> $GITHUB_ENV

      - name: ğŸ‰ Deployment Success Notification
        if: success()
        run: |
          # Get external IPs again for final notification
          FRONTEND_IP=$(kubectl get service frontend -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          BACKEND_IP=$(kubectl get service backend -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          echo "âœ… Deployment successful!"
          echo "ğŸ”— Frontend: http://$FRONTEND_IP"
          echo "ğŸ”— Backend: http://$BACKEND_IP"
          echo "ğŸŒ Environment: ${{ inputs.environment }}"
          echo ""
          echo "ğŸ“‹ To check service status manually:"
          echo "kubectl get services"
          echo "kubectl get pods"
